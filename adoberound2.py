# -*- coding: utf-8 -*-
"""adoberound2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ougW7EIXYb4GwdTbPLiE8VVeF7Eyib79
"""

import csv
import matplotlib.pyplot as plt

def read_polylines(file_path):
    polylines = []
    with open(file_path, 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            polyline = []
            for i in range(0, len(row), 2):
                x, y = float(row[i]), float(row[i + 1])
                polyline.append((x, y))
            polylines.append(polyline)
    return polylines

def visualize_polylines(polylines):
    for polyline in polylines:
        x_vals, y_vals = zip(*polyline)
        plt.plot(x_vals, y_vals)
    plt.show()

# Example usage
polylines = read_polylines('frag01_sol.csv')
visualize_polylines(polylines)

def visualize_polylines(polylines):
    for polyline in polylines:
        x_vals, y_vals = zip(*polyline)
        plt.plot(x_vals, y_vals)
    plt.show()

# Example usage
polylines = read_polylines('frag1.csv')
visualize_polylines(polylines)

import numpy as np
from scipy.spatial import distance

def regularize_straight_lines(polylines):
    regularized = []
    for polyline in polylines:
        # Calculate the Euclidean distance between the first and last points
        d = distance.euclidean(polyline[0], polyline[-1])
        if d > threshold:  # If the distance is greater than a threshold, treat as a straight line
            regularized.append([polyline[0], polyline[-1]])
        else:
            regularized.append(polyline)
    return regularized

# Example usage
threshold = 10  # Adjust based on the scale of your data
regularized_polylines = regularize_straight_lines(polylines)
visualize_polylines(regularized_polylines)

def is_symmetric(polyline):
    n = len(polyline)
    for i in range(n // 2):
        if polyline[i] != polyline[n - 1 - i]:
            return False
    return True

def regularize_symmetric_shapes(polylines):
    regularized = []
    for polyline in polylines:
        if is_symmetric(polyline):
            regularized.append(polyline)  # Keep it as is
        else:
            regularized.append(polyline)  # Apply other regularization
    return regularized

# Example usage
symmetric_polylines = regularize_symmetric_shapes(polylines)
visualize_polylines(symmetric_polylines)

from scipy.interpolate import interp1d

x_vals, y_vals = zip(*polylines)
    if len(polylines) > 2:  # Only interpolate if more than 2 points exist
        f_x = interp1d(range(len(x_vals)), x_vals, kind='linear')
        f_y = interp1d(range(len(y_vals)), y_vals, kind='linear')
        new_polyline = [(f_x(i), f_y(i)) for i in range(len(x_vals))]
        return new_polyline
    return polylines

from scipy.interpolate import interp1d

def complete_curve(polyline):
    x_vals, y_vals = zip(*polyline)  # Unpacking the points into x and y coordinates
    if len(polyline) > 2:  # Only interpolate if more than 2 points exist
        f_x = interp1d(range(len(x_vals)), x_vals, kind='linear')
        f_y = interp1d(range(len(y_vals)), y_vals, kind='linear')
        new_polyline = [(f_x(i), f_y(i)) for i in range(len(x_vals))]
        return new_poly

def complete_curve(polyline):
    if not polyline or len(polyline) <= 2:  # Check for valid input
        return polyline  # Return the original polyline if it's too short or empty

    x_vals, y_vals = zip(*polyline)
    f_x = interp1d(range(len(x_vals)), x_vals, kind='linear')
    f_y = interp1d(range(len(y_vals)), y_vals, kind='linear')
    new_polyline = [(f_x(i), f_y(i)) for i in range(len(x_vals))]
    return new_polyline

import matplotlib.pyplot as plt

def visualize_polylines(polylines):
    for polyline in polylines:
        if polyline:  # Check if polyline is not None and has content
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.show()

from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

def complete_curve(polyline):
    if not polyline or len(polyline) <= 2:
        return polyline

    x_vals, y_vals = zip(*polyline)
    f_x = interp1d(range(len(x_vals)), x_vals, kind='linear')
    f_y = interp1d(range(len(y_vals)), y_vals, kind='linear')
    new_polyline = [(f_x(i), f_y(i)) for i in range(len(x_vals))]
    return new_polyline

def complete_incomplete_curves(polylines):
    completed = []
    for polyline in polylines:
        completed.append(complete_curve(polyline))
    return completed

def visualize_polylines(polylines):
    for polyline in polylines:
        if polyline:
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.show()

# Example usage
polylines = [
    [(0, 0), (1, 2), (2, 3)],
    [(1, 1), (2, 4), (3, 1)],
    []  # Add more polylines as needed
]

completed_polylines = complete_incomplete_curves(polylines)
visualize_polylines(completed_polylines)

def evaluate_curves(original, regularized):
    for i in range(len(original)):
        plt.subplot(1, 2, 1)
        visualize_polylines([original[i]])
        plt.title('Original')

        plt.subplot(1, 2, 2)
        visualize_polylines([regularized[i]])
        plt.title('Regularized')
        plt.show()

# Example usage
evaluate_curves(polylines, regularized_polylines)

pip install svgpathtools

from svgpathtools import svg2paths
import matplotlib.pyplot as plt

def read_svg(file_path):
    paths, attributes = svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                # Handle Bezier curves by sampling points along the curve
                for t in range(11):
                    point = segment.point(t/10)
                    polyline.append((point.real, point.imag))
        polylines.append(polyline)
    return polylines

def visualize_polylines(polylines):
    for polyline in polylines:
        x_vals, y_vals = zip(*polyline)
        plt.plot(x_vals, y_vals)
    plt.gca().invert_yaxis()  # Invert y-axis to match SVG coordinate system
    plt.show()

pip install svgpathtools

import matplotlib.pyplot as plt
from svgpathtools import svg2paths

def read_svg(file_path):
    paths, _ = svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
        if polyline:
            polylines.append(polyline)
    return polylines

import svgpathtools
import matplotlib.pyplot as plt

def read_svg(file_path):
    paths, attributes = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
                # Add more points from the curve if needed
        polylines.append(polyline)
    return polylines

def visualize_polylines(polylines):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.show()

# Load and visualize the SVG
file_path = 'frag2.svg'
polylines = read_svg(file_path)
visualize_polylines(polylines)

import svgpathtools
import matplotlib.pyplot as plt
from shapely.geometry import LineString
from shapely.geometry.polygon import Polygon

def read_svg(file_path):
    paths, attributes = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def simplify_polyline(polyline, tolerance=0.01):
    line = LineString(polyline)
    simplified = line.simplify(tolerance, preserve_topology=True)
    return list(simplified.coords)

def fit_to_rectangle(polyline):
    # Fit the polyline to the nearest rectangle
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    return [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]

def manipulate_to_nearest_shape(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:
            simplified = simplify_polyline(polyline)
            rectangle_fitted = fit_to_rectangle(simplified)
            manipulated_polylines.append(rectangle_fitted)
        else:
            manipulated_polylines.append(polyline)
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.show()

file_path = '/content/frag1.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

manipulated_polylines = manipulate_to_nearest_shape(polylines)

visualize_polylines(manipulated_polylines, title="Manipulated to Nearest Rectangle")

import svgpathtools
import matplotlib.pyplot as plt
from shapely.geometry import LineString
from shapely.geometry.polygon import Polygon

def read_svg(file_path):
    paths, attributes = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def simplify_polyline(polyline, tolerance=0.01):
    line = LineString(polyline)
    simplified = line.simplify(tolerance, preserve_topology=True)
    return list(simplified.coords)

def fit_to_rectangle(polyline):
    # Fit the polyline to the nearest rectangle
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    return [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]

def manipulate_to_nearest_shape(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:
            simplified = simplify_polyline(polyline)
            rectangle_fitted = fit_to_rectangle(simplified)
            manipulated_polylines.append(rectangle_fitted)
        else:
            manipulated_polylines.append(polyline)
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.show()

# Load and visualize the SVG
file_path = '/content/frag2.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

# Manipulate Polylines to Nearest Rectangle
manipulated_polylines = manipulate_to_nearest_shape(polylines)

# Visualize Manipulated Polylines
visualize_polylines(manipulated_polylines, title="Manipulated to Nearest Rectangle")

import svgpathtools
import matplotlib.pyplot as plt
from shapely.geometry import LineString
from shapely.geometry.polygon import Polygon

def read_svg(file_path):
    paths, attributes = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def simplify_polyline(polyline, tolerance=0.01):
    line = LineString(polyline)
    simplified = line.simplify(tolerance, preserve_topology=True)
    return list(simplified.coords)

def fit_to_rectangle(polyline):
    # Fit the polyline to the nearest rectangle
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    return [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]

def manipulate_to_nearest_shape(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:
            simplified = simplify_polyline(polyline)
            rectangle_fitted = fit_to_rectangle(simplified)
            manipulated_polylines.append(rectangle_fitted)
        else:
            manipulated_polylines.append(polyline)
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.show()

# Load and visualize the SVG
file_path = '/content/frag1.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

# Manipulate Polylines to Nearest Rectangle
manipulated_polylines = manipulate_to_nearest_shape(polylines)

# Visualize Manipulated Polylines
visualize_polylines(manipulated_polylines, title="Manipulated to Nearest Rectangle")

import svgpathtools
import matplotlib.pyplot as plt
from shapely.geometry import LineString
from shapely.geometry.polygon import Polygon

def read_svg(file_path):
    paths, attributes = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def simplify_polyline(polyline, tolerance=0.01):
    line = LineString(polyline)
    simplified = line.simplify(tolerance, preserve_topology=True)
    return list(simplified.coords)

def fit_to_circle(polyline):
    # Fit the polyline to the nearest rectangle
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    return [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]

def manipulate_to_nearest_shape(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:
            simplified = simplify_polyline(polyline)
            circle_fitted = fit_to_circle(simplified)
            manipulated_polylines.append(circle_fitted)
        else:
            manipulated_polylines.append(polyline)
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.show()

# Load and visualize the SVG
file_path = '/content/isolated.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

# Manipulate Polylines to Nearest Rectangle
manipulated_polylines = manipulate_to_nearest_shape(polylines)

# Visualize Manipulated Polylines
visualize_polylines(manipulated_polylines, title="Manipulated to Nearest circle")

import svgpathtools
import matplotlib.pyplot as plt
import numpy as np
from shapely.geometry import Polygon, Point, LineString

def read_svg(file_path):
    paths, _ = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def is_rectangle(polyline):
    # Check if polyline forms a rectangle by comparing the aspect ratio
    if len(polyline) < 4:
        return False

    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    width = maxx - minx
    height = maxy - miny
    aspect_ratio = width / height if height != 0 else 0

    return 0.8 < aspect_ratio < 1.2

def is_circle(polyline):
    # Check if polyline forms a circle by analyzing distance variance from the centroid
    x_vals, y_vals = zip(*polyline)
    centroid_x = sum(x_vals) / len(x_vals)
    centroid_y = sum(y_vals) / len(y_vals)
    distances = [np.sqrt((x - centroid_x) ** 2 + (y - centroid_y) ** 2) for x, y in polyline]
    mean_dist = sum(distances) / len(distances)
    variance = sum((d - mean_dist) ** 2 for d in distances) / len(distances)

    # Heuristic: if the variance is small, assume it's a circle
    return variance < (mean_dist * 0.1)  # Adjust threshold as needed

def fit_to_circle(polyline):
    # Fit polyline to the nearest circle
    x_vals, y_vals = zip(*polyline)
    centroid_x = sum(x_vals) / len(polyline)
    centroid_y = sum(y_vals) / len(polyline)
    distances = [np.sqrt((x - centroid_x) ** 2 + (y - centroid_y) ** 2) for x, y in polyline]
    radius = sum(distances) / len(distances)
    circle_polyline = [(centroid_x + radius * np.cos(theta), centroid_y + radius * np.sin(theta)) for theta in np.linspace(0, 2 * np.pi, len(polyline))]
    return circle_polyline

def fit_to_rectangle(polyline):
    # Fit polyline to the nearest rectangle (bounding box)
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    rect_polyline = [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]
    return rect_polyline

def manipulate_polylines(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:  # Ensure there are enough points
            if is_circle(polyline):
                circle_fitted = fit_to_circle(polyline)
                manipulated_polylines.append(circle_fitted)
            elif is_rectangle(polyline):
                rect_fitted = fit_to_rectangle(polyline)
                manipulated_polylines.append(rect_fitted)
            else:
                manipulated_polylines.append(polyline)  # Leave as is if no shape is identified
        else:
            manipulated_polylines.append(polyline)  # Leave as is if not enough points
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

# Load and visualize the SVG
file_path = '/content/occlusion2.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

# Manipulate Polylines based on Shape
manipulated_polylines = manipulate_polylines(polylines)

# Visualize Manipulated Polylines
visualize_polylines(manipulated_polylines, title="Manipulated Polylines")

import svgpathtools
import matplotlib.pyplot as plt
import numpy as np
from shapely.geometry import Polygon, Point, LineString

def read_svg(file_path):
    paths, _ = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def is_rectangle(polyline):
    # Check if polyline forms a rectangle by comparing the aspect ratio
    if len(polyline) < 4:
        return False

    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    width = maxx - minx
    height = maxy - miny
    aspect_ratio = width / height if height != 0 else 0

    return 0.8 < aspect_ratio < 1.2

def is_circle(polyline):
    # Check if polyline forms a circle by analyzing distance variance from the centroid
    x_vals, y_vals = zip(*polyline)
    centroid_x = sum(x_vals) / len(x_vals)
    centroid_y = sum(y_vals) / len(y_vals)
    distances = [np.sqrt((x - centroid_x) ** 2 + (y - centroid_y) ** 2) for x, y in polyline]
    mean_dist = sum(distances) / len(distances)
    variance = sum((d - mean_dist) ** 2 for d in distances) / len(distances)

    # Heuristic: if the variance is small, assume it's a circle
    return variance < (mean_dist * 0.1)  # Adjust threshold as needed

def fit_to_circle(polyline):
    # Fit polyline to the nearest circle
    x_vals, y_vals = zip(*polyline)
    centroid_x = sum(x_vals) / len(polyline)
    centroid_y = sum(y_vals) / len(polyline)
    distances = [np.sqrt((x - centroid_x) ** 2 + (y - centroid_y) ** 2) for x, y in polyline]
    radius = sum(distances) / len(distances)
    circle_polyline = [(centroid_x + radius * np.cos(theta), centroid_y + radius * np.sin(theta)) for theta in np.linspace(0, 2 * np.pi, len(polyline))]
    return circle_polyline

def fit_to_rectangle(polyline):
    # Fit polyline to the nearest rectangle (bounding box)
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    rect_polyline = [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]
    return rect_polyline

def manipulate_polylines(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:  # Ensure there are enough points
            if is_circle(polyline):
                circle_fitted = fit_to_circle(polyline)
                manipulated_polylines.append(circle_fitted)
            elif is_rectangle(polyline):
                rect_fitted = fit_to_rectangle(polyline)
                manipulated_polylines.append(rect_fitted)
            else:
                manipulated_polylines.append(polyline)  # Leave as is if no shape is identified
        else:
            manipulated_polylines.append(polyline)  # Leave as is if not enough points
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

# Load and visualize the SVG
file_path = '/content/occlusion2_rec.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

# Manipulate Polylines based on Shape
manipulated_polylines = manipulate_polylines(polylines)

# Visualize Manipulated Polylines
visualize_polylines(manipulated_polylines, title="Manipulated Polylines")

import svgpathtools

import svgpathtools
import matplotlib.pyplot as plt
import numpy as np
from shapely.geometry import Polygon, Point, LineString

def read_svg(file_path):
    paths, _ = svgpathtools.svg2paths(file_path)
    polylines = []
    for path in paths:
        polyline = []
        for segment in path:
            if isinstance(segment, svgpathtools.Line):
                polyline.append((segment.start.real, segment.start.imag))
                polyline.append((segment.end.real, segment.end.imag))
            elif isinstance(segment, svgpathtools.CubicBezier):
                polyline.append((segment.start.real, segment.start.imag))
        polylines.append(polyline)
    return polylines

def is_rectangle(polyline):
    # Check if polyline forms a rectangle by comparing the aspect ratio
    if len(polyline) < 4:
        return False

    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    width = maxx - minx
    height = maxy - miny
    aspect_ratio = width / height if height != 0 else 0

    return 0.8 < aspect_ratio < 1.2

def is_circle(polyline):
    # Check if polyline forms a circle by analyzing distance variance from the centroid
    x_vals, y_vals = zip(*polyline)
    centroid_x = sum(x_vals) / len(x_vals)
    centroid_y = sum(y_vals) / len(y_vals)
    distances = [np.sqrt((x - centroid_x) ** 2 + (y - centroid_y) ** 2) for x, y in polyline]
    mean_dist = sum(distances) / len(distances)
    variance = sum((d - mean_dist) ** 2 for d in distances) / len(distances)

    # Heuristic: if the variance is small, assume it's a circle
    return variance < (mean_dist * 0.1)  # Adjust threshold as needed

def fit_to_circle(polyline):
    # Fit polyline to the nearest circle
    x_vals, y_vals = zip(*polyline)
    centroid_x = sum(x_vals) / len(polyline)
    centroid_y = sum(y_vals) / len(polyline)
    distances = [np.sqrt((x - centroid_x) ** 2 + (y - centroid_y) ** 2) for x, y in polyline]
    radius = sum(distances) / len(distances)
    circle_polyline = [(centroid_x + radius * np.cos(theta), centroid_y + radius * np.sin(theta)) for theta in np.linspace(0, 2 * np.pi, len(polyline))]
    return circle_polyline

def fit_to_rectangle(polyline):
    # Fit polyline to the nearest rectangle (bounding box)
    poly = Polygon(polyline)
    minx, miny, maxx, maxy = poly.bounds
    rect_polyline = [(minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]
    return rect_polyline

def manipulate_polylines(polylines):
    manipulated_polylines = []
    for polyline in polylines:
        if len(polyline) > 2:  # Ensure there are enough points
            if is_circle(polyline):
                circle_fitted = fit_to_circle(polyline)
                manipulated_polylines.append(circle_fitted)
            elif is_rectangle(polyline):
                rect_fitted = fit_to_rectangle(polyline)
                manipulated_polylines.append(rect_fitted)
            else:
                manipulated_polylines.append(polyline)  # Leave as is if no shape is identified
        else:
            manipulated_polylines.append(polyline)  # Leave as is if not enough points
    return manipulated_polylines

def visualize_polylines(polylines, title=""):
    for polyline in polylines:
        if polyline:  # Ensure polyline is not empty
            x_vals, y_vals = zip(*polyline)
            plt.plot(x_vals, y_vals)
    plt.title(title)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

# Load and visualize the SVG
file_path = '/content/frag0.svg'
polylines = read_svg(file_path)

# Visualize Original Polylines
visualize_polylines(polylines, title="Original Polylines")

# Manipulate Polylines based on Shape
manipulated_polylines = manipulate_polylines(polylines)

# Visualize Manipulated Polylines
visualize_polylines(manipulated_polylines, title="Manipulated Polylines")

